# 2. Шаблонизация веб-страниц приложения

Целью данной лабораторной работы является получение навыков работы с шаблонизаторами пользовательских представлений.

Для выполнения данной лабораторной работы вам необходимо подключить шаблонизатор ([любой из списка](https://expressjs.com/en/resources/template-engines.html)) и выделить повторяющиеся блоки в отдельные представления в вашем проекте

Чтобы зарегистрировать выбранный вами шаблонизатор в приложение NestJS, необходимо выполнить его явно определить при инициализации приложения согласно [инструкции в документации](https://docs.nestjs.com/techniques/mvc#model-view-controller).

Части (partials) веб страниц обязательных к выделению в отдельные представления:

* Shared Script / Style bundles (общие стили и скрипты используемые на всех страницах повсеместно)
* Header (Заголовок)
* Пункты меню
* Информация о сессии (Вы вошли как … / Кнопка регистрация и т.д.)
* Content (Контейнер под основное содержание страницы)
* Footer (Подвал)
* Кол-во времени затраченного на выдачу страницы сервером

Ввиду отсутствия, на данный момент, контроллеров и маршрутов для ваших страниц, необходимо будет их добавить для обеспечения возможности рендеринга ваших представлений, например:

```ts
@Controller()
export class AppController {
    @Get()
    @Render('index') // <= Название вашего представления
    getIndexPage() {
        return { user: 'Hello world!' }; // Модель представления
    }
}
```

Подготовьте как минимум два состояния для представления информации о текущей сессии пользователя (Авторизован и неавторизован).

![](https://i.imgur.com/Dp9rv3C.png)

После того как все представления будут готовы, необходимо обновить поле отвечающее за то, сколько времени потребовалось для отрисовки страницы, но, с включением того времени, которое понадобилось серверу для его обработки.

Для решения данной задачи рекомендуется имплементировать свой класс типа [Interceptor](https://docs.nestjs.com/interceptors) и зарегистрировать его для выполнения перед каждым запросом внутри NestJS приложения. По сути ваш перехватчик запросов будет выполнять роль [логгирующего заместителя](https://refactoring.guru/ru/design-patterns/proxy) с сохранением времени потраченного на обработку запроса непосредственно в HTTP ответе.

Т.к. Interceptor’ы используют концепции реактивного программирования, для того чтобы трансформировать ответ отправляемый сервером, необходимо будет создать подписку на объект наблюдения средствами RxJS. Рекомендуется ознакомиться с [документацией по RxJS](https://www.learnrxjs.io/learn-rxjs/operators/transformation) прежде чем применять [готовый рецепт](https://www.learnrxjs.io/learn-rxjs/operators/transformation) для модификации ответов.

После того как вы добавите метаданные (например в Header’ы ответа) о том, сколько времени понадобилось серверу на формирование страницы, добавьте это время к тому сколько браузер генерировал DOM и отобразите эту информацию на ваших страницах в подвале:

![](https://i.imgur.com/ECrRQsu.png)
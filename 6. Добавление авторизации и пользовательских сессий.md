# 6. Добавление авторизации и пользовательских сессий

В результате выполнения лабораторной работы на разрабатываемом веб-сайте должны быть реализованы механизмы авторизации через сторонних поставщиков услуг и аутентификации на целевом ресурсе.

Для выполнения данной лабораторной работы вам необходимо реализовать в ранее созданном приложении модуль, который бы отвечал за предоставление прав в рамках пользовательской сессии внутри контроллеров, спроектированных в рамках предыдущей лабораторной работы.

Авторизация на вашем ресурсе позволяет пользователю получить доступ к изменению настроек своей учетной записи, интерфейса взаимодействия с системой, паролей, типовых операций, внесение изменений в систему. До выполнения авторизации, посетитель сайта может использовать лишь ограниченный набор функций.

Для удовлетворения всех стандартов безопасности, которые существуют на сегодняшний день предлагается вместо того, чтобы разрабатывать свой механизм авторизации, воспользоваться поставщиками таких услуг как Authorization as a Service/as a Platform. Зачем пользоваться сторонним решением для того чтобы провести аутентификацию пользователя? Вы не можете обеспечить надлежащее управление данными и безопасность. Иными словами, если вы не Папа Джонс, то изготовление пиццы с нуля может пойти не так.

В зависимости от того, насколько сильную кастомизацию UI/UX вы хотите, предлагаю рассмотреть следующих поставщиков услуг:
- [Auth0](https://auth0.com/) — это платформа, предоставляющая готовые решения для разработки сервисов любого уровня сложности. Auth0 поддерживается командой, стоящей за разработкой JWT (JSON Web Token). Полностью проприетарный продукт. Предоставляют как Backend для авторизации, так и настраиваемую форму для ввода логина/пароля со своей стороны. Существуют готовые рецепты для интеграции с приложениями написанными на NodeJS. <u>Но на данный момент не предоставляют свой сервис для клиентов регистрирующихся из России</u>.
- [Super Tokens](https://supertokens.com/) — это альтернатива AuthO с полностью открытым исходным кодом, которая позволяет настроить аутентификацию менее чем за 30 минут. Есть возможность воспользоваться Managed Infrastucture, т.е. сам сервер авторизации (Identity Provider) доступен вам как облачное решение(используют AWS для размещения своих серверов). Комплексное решение, включающее вход в систему, регистрацию, управление пользователями и сеансами без сложностей протоколов OAuth.
- [Google FireBase Auth](https://firebase.google.com/docs/auth/web/firebaseui) - Это система аутентификации на основе токенов, которая обеспечивает легкую интеграцию с большинством платформ. в свое приложение авторизацию можно добавить с помощью пакета SDK. Есть возможность использовать как свою форму для входа так и стандартную, предоставляемую самим сервисом.

В рамках данной лабораторной не столь важно каким именно поставщиком услуг вы воспользуетесь для того чтобы авторизовывать пользователей, но я рекомендую остановить свой выбор на системе SuperTokens т.к. здесь вам необходимо будет реализовать все необходимые классы внутри вашего приложения самим, что добавит понимания о том как именно происходит сам процесс авторизации!

Далее будут расписаны <u>требования к реализации модуля</u> авторизации и аутентификации на примере сервиса SuperTokens, но эти требования характерны и в случае использования других сервисов.

После регистрации и выборе типа размещения вашего авторизационного сервиса (Managed Infrastructure) вам будет сгенерирована конфигурация для тестовой (Development) среды и для боевой (Production) среды:

![пикча](https://imgur.com/kcagJKF.png)

**Всю конфигурацию необходимо вынести в переменные среды окружения**. Сделать это можно таким же образом как и для строки подключения к базе, через Dashboard приложения на сайте render.com

![пикча](https://i.imgur.com/dZe63Mt.png)

Весь код для подключения модуля авторизации необходимо вынести в отдельный инфраструктурный слой согласно лучшим практикам DDD.

После того как вы вынесите необходимые данные для подключения рекомендуется ознакомится с теми подходами, которые предоставляются тем или иным поставщиком услуг. Вы можете выбрать авторизацию по ссылкам на почту, с помощью сторонних ресурсов либо классический вариант, через логин и пароль.

Создайте отдельный модуль внутри вашего приложения, это можно сделать используя команду `nest g module auth`

Внутри модуля **необходимо реализовать** возможность его конфигурации в момент выполнения программы путем **передачи конфигурации при регистрации модуля**. Такой подход в Nest называется [динамические модули](https://docs.nestjs.com/modules#dynamic-modules). т.е. конфигурационные значения из переменных окружения вычитываются на старте приложения и передаются в статический метод вашего динамического модуля, для получения сконфигурированного экземпляра, который будет доступен непосредственно при инъекции зависимостей в другие ваши модули.

Далее, вам так или иначе необходимо будет разграничить какие ресурсы вы готовы предоставлять всем пользователям, а какие только тем, кто является авторизованным пользователями. Для этого рекомендуется воспользоваться Nest’овскими [Guard](https://docs.nestjs.com/guards)’ами. Вы можете использовать уже готовые шаблонные AuthGuard’ы из npm пакета PassportJS, каким либо готовым из SDK пакета того поставщика услуг при наличии, либо написать свой Guard, заточенный под ваш конкретный вариант использования.

Ваш AuthGuard должен реализовывать интерфейс **CanActivate** и в зависимости от того, авторизован ли пользователь, возвращать true либо false. Методы контроллера, требующие авторизацию необходимо декарировать в помощью <u>@UseGuard(ВашAuthGuard)</u>

У guards есть единственная ответственность. Они определяют, будет ли данный запрос обработан обработчиком маршрута или нет, в зависимости от определенных условий (таких как разрешения, роли, ACL и т.д.), существующих во время выполнения. Это часто называют авторизацией. Аутентификация, с которой обычно взаимодействует AuthGuard обрабатывается через middleware в традиционных приложениях Express. Middleware - отличный выбор для аутентификации, поскольку такие вещи, как проверка токенов и прикрепление свойств к объекту request, не сильно связаны с конкретным контекстом маршрута (и его метаданными). Они, как и фильтры исключений, pipes и interceptors, предназначены для того, чтобы вы могли вмешаться в логику обработки в нужный момент цикла запроса/ответа, Это помогает сохранить ваш код цельным и декларативным.

Как вы поняли, в случаях, когда пользователь запрашивает ресурс, доступный только авторизованным пользователям, но при этом, в текущей сессии процесс идентификации ещё не был произведён, необходимо переадресовать пользователя на форму входа. Для этого необходимо **реализовать** свой **Middleware**, который бы обрабатывал этот сценарий. Для подключения такого обработчика к конкретному контроллеру рекомендуется воспользоваться Nest’овским подходом [Middleware Consumer](https://docs.nestjs.com/middleware#middleware-consumer) при регистрации того или иного контроллера внутри модуля.

После того как вы добавите Guards & Middleware, необходимо также обозначить в документации к вашему API, какие именно методы требуют авторизации и какая именно схема используется для этого. SwaggerModule поддерживает несколько [стандартных типов схем](https://docs.nestjs.com/openapi/security). Выберите ту схему авторизации, которую предоставляет ваш поставщик услуг и [декорируйте](https://docs.nestjs.com/openapi/decorators) те контроллеры, куда вы только что добавляли указание использовать AuthGuard. Если этот шаг сделан верно, то на методах, требующих авторизацию появится значок замочка. см пример ниже:

![pic](https://i.imgur.com/djmSIvD.png)

После этого, т.к. вы уже знаете как именно передается авторизационный токен (в cookie или в конкретных Header’ах), необходимо настроить [CORS Policy](https://docs.nestjs.com/security/cors) внутри вашего приложения в файле main.ts:

![pic](https://i.imgur.com/DZx1HB9.png)

Если вы используете не SuperTokens, то набор разрешённых Header’ов должен
содержать все заголовки, отличающиеся от [стандартных](https://developer.mozilla.org/ru/docs/Web/HTTP/CORS).

К этому моменту считаем что у нас есть вся необходимая обвязка для проверки токена, осталось его выпустить. Если ваш поставщик услуг авторизации не предоставляет готового frontend’a с логин формой, необходимо сверстать её самостоятельно и послать запрос к авторизационному сервису.

В случаях если вы используете OAuth 2.0, то попросите соотвествующие Grant’ы у Identity Provider’a и обменяйте полученный код на авторизационный токен.

В случаях если вы не используете OAuth 2.0, как например в SuperTokens, просто обратитесь на Authorization Endpoint с указанием схемы авторизации.

Если форма с логином ещё не готова, то для проверки рекомендую воспользоваться HttpClient’ом например Postman:

Делаем запрос на авторизационный сервис:

![pic](https://i.imgur.com/neLEs3V.png)

Убеждаемся что получен валидный ответ и юзер прошёл авторизацию, получаем Cookies (в моём случае я выбрал авторизацию через Cookie).

В соседней вкладке смотрим что мы получили (см. скриншот ниже):

![pic](https://i.imgur.com/aYgn2rA.png)

Был получен AccessToken, т.е. то что нам нужно для того обращаться в нашим ресурсам.

Внутри AccessToken cookie лежит JWT токен с идентификатором пользователя. Для отладки можно воспользоваться сервисом https://jwt.io

![pic](https://i.imgur.com/nYwTLX3.png)

Как видим, у пользователю был выдан GUID идентификатор - 034e77a6-627d-4b3a-b689-e44c6b1faf02

В дальнейшем всё что нам нужно сделать это вычитать из токена этот userId и связать с тем пользователем который есть у вас в базе данных.

P.S. SuperTokens уже имеет свою обвязку чтобы это делать, см. документацию.

![pic](https://i.imgur.com/XLZOj0D.png)

Если ваше веб-приложение поддерживает аутентификацию и разделение пользователей по ролям, то как второй шаг вы можете выдать роли, соответствующие вашему пользователю уже после прохождения авторизации. Для этого, [согласно документации](https://docs.nestjs.com/security/authorization), вам также нужно будет декорировать необходимые методы контроллера с помощью Guard’ов с указанием той или иной роли, необходимой для доступа к вашему методу.

После реализации всех шагов, обновите ваши вьюшки и подкладывайте в контекст информацию о пользователе, чтобы в зависимости от того, вошёл пользователь или нет, в шапке вашего сайта предлагалось либо войти, либо отображалась информация о пользователе.

![pic](https://i.imgur.com/aScSKdG.png)

Удачи :)